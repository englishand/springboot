######5种数据类型
    1.String 字符串（可以为整形、浮点型和字符串，统称为元素）
        常用命令：set name value,get name,自加incr,自减decr,加incrby,减decrby
    2，list 列表（实现队列，元素不唯一，先进先出原则）
        lpush:从左边推入，rpush从右边推入,lpop从左边弹出，rpop从右边弹出，llen查看某个list数据类型的长度。例：lpush list1 aaa
    3.set 集合（各个不相同的元素）
        sadd添加数据，scard查看set数据种存在的元素个数，sismember判断set数据中是否存在某个元素，srem删除某个set数据中的元素。
    4.hash hash散列值（hash的key必须是唯一的）
        hset添加hash元素，hget获取hash数据，hmget获取多个hash数据
    5.sorted set：有序集合，和hash相似，也是映射形式的存储
        zadd添加，zcard查询，zrange数据排序
    6.redis客户端连接：redis-cli -h 地址 -p 6379
#####多个数据库
    Redis支持多数据库，并且每个数据库的数据是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。Redis是一个字典结构的存储服务器，而实际上
    一个Redis实例提供了多个用来存储数据的字典，每个字典可以理解为一个独立的数据库。每个数据库对外都以一个从0开始的递增数字命名，默认支持16个数据库，可
    以通过配置databases来修改。可以通过select命令更换数据库，如：select 1，即选取1号数据库。Redis不支持自定义数据库的名字，每个数据库以编号命名。也
    不支持为每个数据库设置不同的密码。多个数据库之间不是完全隔离的，如flushall命令可以清空一个Redis实例中所有数据库数据，
#####持久化
    1.持久化流程：客户端向服务端发送写操作（数据在客户端内存中），服务端接收到请求的数据（数据在服务端的内存中），服务端调用write系统调用将数据
        往硬盘上写（数据在系统内存的缓冲区上），操作系统将缓冲区中的数据移动到硬盘控制器上（数据在硬盘缓存中），硬盘控制器将数据写到硬盘的物理介质上
        （数据真正落到硬盘上）。
        考虑redis实现上面5个保存硬盘的步骤，Redis提供了两种策略机制，即：RDB和AOF
    2.RDB机制
        RDB就是把数据以快照的形式保存在硬盘上。RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入硬盘。也是默认的持久化方式，这种方式就是就是将
        内存中数据以快照的方式写入到二进制文件中，默认文件名：dump.rdb。既然RDB机制是通过把某个时刻的所有数据生成一个快照来保存，那么就有一种触发机
        制实现这个过程。对于RDB来说，提供了三种机制：save、bgsave、自动化。
        1.save触发机制：该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成。执行完毕后如果存在老的RDB文件，就把
        老的替换掉。
        2.bgsave触发方式：执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体操作是Redis进程执行fork操作创建子进程，RDB
        持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上Redis内部所有的RDB操作都是采用bgsave命令。
        3.自动触发：
            a. save m n 配置规则自动触发；m表示时间，n表示数据修改次数
            b. 从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会触发 bgsave;
            c. 执行 debug reload时；
            d. 执行shutdown时，如果没有开启aof，也会触发。
        优势和劣势：（优势）RDB文件紧凑，全量备份，适用于进行备份和灾难恢复。生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主
        进程不需要进行任何硬盘IO操作。RDB在恢复大数据集时的速度比AOF的恢复速度要快。（劣势）RDB快照是一次全量备份，存储的是内存数据的二进制序列化形
        式，存储非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程可能不会反应过来，
        所以在快照持久化期间修改的数据不会被保存，可能丢失数据。
    3.AOF机制
        持久化原理：一种高效机制，redis会将每一个收到的写命令都通过write函数追加到文件中。
        文件重写原理：AOF方式带来的问题，持久化文件越来越大。为了压缩aof的持久化文件，redis提供了bgrewriteaof命令，将内存中的数据以命令的方式保存到
        临时文件中，同时会fork出一条新进程来将文件重写。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个
        新的aof文件。
    4.两种机制比较：
        RDB：启动优先级低，体积小，恢复速度块，数据安全性：丢数据
        AOF:启动优先级高，体积大，恢复速度慢，数据安全性：根据策略决定
#####基于redis实现分布式锁
    背景：原单体单机部署的系统被演化成分布式集群部署系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制策略失
        效，单纯的应用不能提供分布式锁的能力。为了解决这个问题就需要一种跨机器的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题。
    Redis提供setnx、getset命令，实现分布式锁机制。
    Redis命令介绍：
        SETNX命令(set if not exists)
        语法：SETNX key value
        功能：当且仅当key不存在，将key的值设为value，并返回1；若key已存在，则setnx不做任何操作，返回0；
        GETSET命令
        语法：GETSET key value
        功能：将给定key的值设为value，并返回key的旧值，当key存在但不是字符串类型时，返回一个错误，当key不存在时，返回nil;
        GET命令
        语法：GET key
        功能：返回key所关联的字符串值，如果key不存在那么返回特殊值nil
        DEL命令
        语法：DEL key [KEY ...]
        功能：删除给定的一个或多个key,不存在的key会被忽略。
#####缓存雪崩和缓存穿透的解决方法
    1.缓存穿透：当用户查询的key在redis缓存中不存在，对应的id在数据库也不存在，此时被非法用户进行攻击，大量的请求会直接打在db上，造成宕机，从而影响
        整个系统，这种现象为缓存穿透
    2.解决方案：
       （1）把空的数据也缓存起来，比如空字符串、空对象、空数组或list,如：
        if(list!=null && list.size()>0){
            redisOperator.set("subCat:"+rootCatId,JsonUtils.objectToJson(list));
        }else{
            redisOperator.set("subCat:"+rootCatId,JsonUtils.objectToJson(list),5*60);
        }//这样下次有相同的key来访问的时候，在缓存失效之前，都可以直接从缓存中获取数据。
        (2)布隆过滤器：判读一个元素是否在一个数组里面，利用二进制去做的一个存储，占用内存较小，0代表不存在，1代表存在，添加查询效率快，当保存了一个
        数值会经过一个算法将对应的值保存到布隆过滤器的集合上的某个位置，某个位置上可能会存在多个key,当传进来一个不存在的key值和集合进行匹配，如果匹
        配不上便返回一个null。该数组为bitmap;
    3.缓存雪崩：缓存中的数据大批量失效，然后这时又有大量的请求进来，但由于redis中的key全部失效所有请求会到db上，造成宕机。
    4.解决方案：
        第一种：redis高可用，常见的两种方式1.主从复制（Replication-Sentinel模式）2.Redis集群（Redis-Cluster模式）
        第二种：多缓存结合，如：请求进入，可以先请求redis,当redis中不存在的时候再去请求memcache,如果都没有再去请求db
        第三种：限流组件（hystrix），可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求走降级，可以返回一些默认的值，或友情提示，或空白的值。
        第四种：redis持久化，一旦重启，自动从硬盘上加载数据，快速恢复缓存数据。
        第五种：将热点数据设置为永远不过期；   