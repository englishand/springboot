#####nio和bio区别
    1.bio是面向流的，而NIO是面向缓冲区的
    2.bio的流是同步阻塞的，而NIO的同步非阻塞的。
        阻塞IO模型：当用户线程发出IO请求后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，当数据就绪后，内核会
        将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。
        非阻塞IO模型：当用户线程发起一个read后，并不需要等待，而是马上得到一个结果。如果结果是一个error时，即结果还没有准备好，于是再次发送read操作，
        一旦内核中的数据准备好了，并再次收到用户线程请求，则将数据拷贝到用户线程并返回。事实上，用户线程不断的询问内核数据受否就绪，即非阻塞IO不会交
        出CPU，而会一直占用CPU。
    3.BIO的阻塞是让线程直接等待，而NIO是等待接收完数据后再让线程来处，在等待接收数据的同时可以处理其他事务
    4.BIO是采用输入输出流来处理数据，NIO是通过通道和缓冲区来处理数据
    5.BIO是单向的如使用inputStream和outPutStream，而NIO是双向。
#####线程切换
    线程切换，就是将一个线程处理完成的数据交给另一个线程来处理，切换的本质是：数据的切换，即将数据从一个线程传递到另一个线程。
#####进程切换
    系统中每个程序都是运行在某个进程的上下文中的。所以进程切换就是上下文的切换。
    上下文是由程序正确运行所需要的状态组成的，这个状态包括存放在存储器中的程序的代码和数据、它的栈、通过目的寄存器的内容、程序计算器、环境变量以及打开
    文件描述符的集合。   
#####关键字
    一.Volatile
        术语：
            1.共享变量：在多个线程之间能被共享的变量称共享变量，包括：实例变量、静态变量和数组元素。放在堆内存中，Volatile只作用于共享变量。
            2.缓冲行：缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个 主内存读周期 的时间。
            3.原子操作：不可中断的一个或系列操作。
        定义：Java允许线程访问共享变量，确保共享变量能准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。如果一个字段被声明成volatile,java
            线程内存模型确保所有线程看到这个变量的值是一致的。
        为什么使用volatile：Volatile变量修饰符如果使用恰到的化，比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。
        实现原理：
            Java代码：instance = new Singleton();//instance是volatile变量
            汇编代码：0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: lock addl $0x0,(%esp);
            有volatile变量修饰的共享变量进行操作的时候会多第二行汇编代码，lock前缀的指令在多核处理器下会引发两件事：
                1.将当前处理器缓存行的数据会写回到系统内存。
                2.这个写回内存的操作会引起其他在 CPU里缓存了该内存地址的数据无效。
        作用：
            1.保证内存可见性
              所有线程的共享变量都存在主内存中，每个线程都有一个独立的工作内存，每个线程不直接操作在主内存中的变量，而是将主内存上变量的副本放进自己
              的工作内存，只操作工作内存中的数据。当修改完后，再把修改的结果放到主内存中。每个线程只操作自己工作内存中的变量，无法直接访问对方工作内
              存中的变量，线程间变量值的传递需要通过主内存来完成。
              在多线程的环境下可能会出现脏数据，即多个线程同时取得变量时，多个线程都对该变量进行了操作，于是就出现了错误。
              如果对变量i加上volatile关键字修饰的话，它可以保证A线程对变量i做了变动之后，会立即刷回到内存中，而其他线程读取到该变量的值也作废，强迫
              重新从主内存中读取该变量的值，这样任何时刻，多个线程总是看到变量i的同一个值。
              1.1.MESI缓存一致性协议
                 IA-32处理器和Intel 64处理器使用MESI(修改、独占、共享、无效)控制协议去维护内部缓存和其他处理器缓存的一致性。IA-32和Intel 64处理器
                 使用嗅探技术保证它的内部缓存，系统内存和其他处理器的缓存数据在总线上保持一致。
            2.禁止指令重排序
              如 instance = new Singleton();该行代码并不是原子操作，其在JVM中被分为如下三个阶段执行：
                （1）为instance分配内存
                （2）初始化instance
                （3）将instance变量指向分配的内存空间
              由于JVM可能存在重排序，上述的二三步没有依赖关系，可能会先执行（3），再执行（2）。即会出现instance变量没有初始化完成，其他线程就已经判
              断了该变量值不为null，结果返回一个没有初始化完成的半成品。加上volatile关键字修饰后，可以保证instance变量的操作不会被JVM所重排序。
            3.不保证原子性
              尽管volatile关键字可以保证内存可见性和执行的有序性，但不保证原子性。即对volatile修饰的变量进行的操作，不保证多线程安全。
    二.synchronized
        1.如何使用：
        方法一：实例方法（锁的是实例对象）
            修饰实例方法，作用于当前实例加锁，进入同步代码前要获取当前实例的锁。当一个线程正在访问一个对象的synchronized的实例方法，那么其他线程不能
            访问该对象的其他synchronized方法，因为一个对象只有一把锁，当一个线程获取了该对象的锁后，其他线程无法获取该对象的锁，所以无法访问该对象的
            其他synchronized方法。
            如果两个线程分别访问两个实例对象（同一个类）的synchronized方法，并且两个线程操作数据是共享数据，那么线程安全就无法保证。解决方法：将
            synchronized作用于静态的方法，这样，对象锁就是当前类对象（类对象只有一个），所有在这样的情况下对象锁就是唯一的。
        方法二：静态方法（锁的是类对象）
            由于静态成员不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态成员变量的并发操作。
        方法三：同步代码块（代码块根据配置，锁的是实例对象也可以是类对象）
            使用同步代码块的方式对需要同步的代码进行包裹。如：
            public void run(){
                synchronized(instance){
                    业务代码；
                }
            } ;
            从代码看出，将synchronized作用于一个给定的实例对象instance，每次当线程进入synchronized包裹的代码块时就会要求当前线程持有instance实例
            对象锁，如果当前有其他线程持有该对象锁，那么新到的线程就必须等待。除了instance作为对象外，还可以使用this对象（代表当前实例）或者使用
            类名.class当前类的class对象作为锁。
        2.monitor机制
            Synchronized是通过对象内部的一个叫监视器锁（monitor）来实现的，监视器锁本质是依赖于底层的操作系统的Mutex Lock(互斥锁)来实现的。而操作
            系统实现线程之间的切换需要CPU从用户态转换到核心态，状态之间的转换需要相对比较长的时间，这就是Synchronized低效率的原因。这种依赖于操作系
            统Mutex Lock所实现的锁称之为“重量级锁”，JDK6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。
            Monitor是一个同步工具，内置于每一个Object对象中，相当于一个许可证。拿到许可证即可以进行操作，没有拿到则需要等待。同时monitor中有一个
            Owner字段存放拥有该锁的线程的唯一标志，表示该锁被这个线程占用。
            synchronized(lock)加锁时，锁对象是可以任意对象，原因：
                1.synchronized(lock)加锁时，用到的其实只是lock对象内置的monitor而已。
                2.一个对象的monitor是唯一的，线程拿到monitor才可以执行，执行完后释放对象的monitor才可以被其他线程获取。
                synchronized加锁的同步块的执行过程：
                synchronized(Object lock){
                    同步代码;
                }
                在字节码文件中被编译为：
                    monitorenter;//获取monitor许可证，进入同步块
                    同步代码；
                    monitorexit;//离开同步块，释放monitor
            锁的可重入性：
                若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入
                （reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行
                的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。
        3.synchronized的happens-before关系：
            Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。
        4.锁优化
            1.Java对象头
              synchronized是悲观锁，在操作同步资源之前需要给同步资源加锁，这把锁就存在Java对象头里。其主要包括：Mark Word(标记字段)、Klass Pointer
              (类型指针)。在同步的时候是获取对象的monitor,即获取到对象的锁，类似于对象的一个标志，那么这个标志就是存在Java对象的对象头。
              Mark Word：默认的存放的对象的Hashcode、分代年龄和锁标记位。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的
              数据会随着锁标志位的变化而变化。
              Klass Pointer:对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象属于哪个类的实例。
              32位JVM Mark Word默认存储结构为：
              ---------------------------------------------------------------------------------------------
                锁状态         25bit                  4bit        1bit是否是偏向锁          2bit锁标志位
                无状态锁      对象的hashcode        对象分代年龄       0                         01
              ---------------------------------------------------------------------------------------------
              Java SE 1.6中，锁一共有四种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐
              升级。锁可以升级但不能降级，这中策略，目的是为了提高获得锁和释放锁的效率。
            2.CAS操作
              （1）什么是CAS
                  使用锁时，线程获取锁是一种悲观锁策略，即假设每一次执行临界区代码都会产生冲突，所以当前获取到锁时同时会阻塞其他线程获取该锁。而CAS
                  操作是一种乐观锁策略，它假设所有线程访问共享资源时不会出现冲突，即不会阻塞其他线程的操作。因此线程不会出现阻塞停顿的状态。如果出现
                  冲突，无锁操作即CAS操作使用CAS又叫做比较交换来鉴别线程是否出现冲突，出现冲突就重试当前操作直到没有冲突为止。
              （2）CAS的操作过程
                  CAS比较交换的过程可以通俗的理解为CAS(V,O,N),包含三个值为：V内存地址存放的实际值，O预期的值（旧值），N更新的新值。当V和O相同时，
                  即旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值O就是最新值，即可以将新值N赋值给V。如果V和O不相同，表明该值已被其
                  他线程改过了，所以不能将N赋给V，返回V即可。当多个线程使用CAS操作一个变量时，只有一个线程会成功，其他线程会失败。失败的线程会重新
                  尝试。
#####锁 
    线程释放synchronized修饰的代码块锁的方式有两种：
        1.该线程执行完代码对应代码，自动释放锁
        2.在执行该代码块发生了异常，JVM会自动释放锁
    采用synchronized关键字来实现同步，如果存在多个线程执行该代码块，而当前获取到锁的线程没有释放锁，其他线程只有等待，这将严重影响执行效率。Lock锁
    机制就是解决该现象。Lock是一个接口，使用Lock时，必须手动进行锁的释放，否则容易出现死锁。
    ReentrantLock是Lock的唯一实现类。其是可重入锁，由构造方法可知，该锁支持两种模式：公平锁和非公平锁。默认是非公平锁。
        public ReentrantLock(){sync = new NonfairSync();} 
        public ReentrantLock(boolean fair){sync=fair?new FairSync():new NonfairSync();}     
    1.公平锁和非公平锁
      公平锁是指当线程A获取到锁时，此时内部计数器num+1,其他线程想访问线程，就会排队等待，直到线程A释放锁（num=0）,此时会唤醒处于等待状态的线程进行
      获取锁的操作。
      非公平锁：当线程A在释放锁后，等待对象的线程会进行资源竞争，竞争成功的线程获取该所锁，其他线程继续睡眠。
      公平锁是严格的以FIFO的方式进行锁的竞争。非公平锁是无序的竞争，刚释放锁的线程很大程度上能较快的获取到锁，队列中的线程只能等待，所以非公平锁可
      能会有“饥饿”的问题。公平锁是严格的线程切换，这样对操作系统的影响是较大的，所以非公平锁的吞吐量是大于公平锁的，因此JDK将非公平锁作为默认的实现
      通过源代码对比，公平锁和非公平锁的lock()方法唯一的区别在于公平锁在获取同步状态时多了一个限制条件：hasQueuePredecessors(),该方法主要判读当前
      线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。
    2.可重入锁和非可重入锁
      可重入锁又名递归锁，是指同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象是同一个对象或class对象）,不会因为之前
      已经获取过还没释放而阻塞。Java中ReentranLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。
      public class Wiget{
            public synchronized void doSomething(){
                System.out.println("方法1");
                doOthers();
            }
            public synchronized  void doOthers(){
                System.out.println("方法2");
            }
      }
      上面代码，类中的两个方法都被内置锁synchronized修饰，因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获取当前对象的锁，进入
      doOthers()进行操作。
      如果是一个不可重入锁，那么当前线程在调用doOthers()前需要将执行doSomething()时获取到的锁释放掉，实际上该对象锁已被该线程所拥有，且无法释放，
      所以会导致死锁。
    3.乐观锁和悲观锁
      Java中，synchronized关键字和Lock的实现类都是悲观锁。
      乐观锁在使用数据时不会加锁，只是在更新数据时判断是否有其他线程更新了这个内存中的数据，如果数据没有被更新，则当前线程将自己修改的数据成功写入。
      如果数据已被其他线程更新，则根据不同的实现方式执行不同的操作（如：报错或自动重试）。
      乐观锁的调用方式：
            private AtomicInteger atomicInteger = new AtomicInteger();//需要保证多个线程使用同一个AtomicInteger
            atomicInteger.incrementAndGet();//执行自增1
      乐观锁的2种实现机制：
         1.版本号机制，一般在数据表中加一个版本号version字段，表示数据被修改的次数，当数据被修改时，version值加1。当线程A需要更新数据值时同时也会
         读取version值，在提交时若读到的version值与当前数据库中version值相等时才更新，否则重新操作，直到成功。
         2.CAS算法，即compare and swap(比较和互换)，是一种无锁算法。即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程阻塞的情况下实现
         变量的同步，所以也叫非阻塞同步。CAS算法涉及到的3个操作数：1.需要读写的内存值V 2.进行比较的值A 3.拟写入的值B 当且仅当V的值等于A时，CAS通过
         原子方式用新值B来更新V的值，否则不进行任何操作，（“比较”+“更新”整体是一个原子操作） 
      乐观锁的主要实现方式就是CAS，这也就是乐观锁做到不锁定资源也可以正确的实现线程同步。
    4.独享锁和共享锁
      独享锁也叫排他锁，是指该所只能被一个线程所持有。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。
      共享锁是指该锁可被多个线程锁持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排他锁。获取共享锁的线程只能读数据，不能修改
      数据。
      独享锁和共享锁是通过AQS来实现的，通过不同的实现方法，来实现独享和共享。
    5.无锁、偏向锁、轻量级锁、重量级锁
      这四种锁是指锁的状态。专门针对synchronized。对应锁对象Mark Word的锁标志位为 01（无锁）、0（是否为偏向锁）、00（轻量级锁）、10（重量级锁）  
      无锁：
         没有对资源进行锁定，所有的线程都能访问并修改同一资源，但同时只有一个线程能修改成功。其他修改失败的线程会不断重试直到修改成功。CAS原理及应用
         即是无锁的实现。
      偏向锁：
         一段代码一直被一个线程所访问，那么线程会自动获取锁，降级获取锁的代价。锁总是由同一线程获取，不存在多线程竞争，所以出现了偏向锁。偏向锁在JDK6
         及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。
      轻量级锁：
         当锁是偏向锁的时候，被另外的线程访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式获取锁，不会阻塞，从而提高性能。
      重量级锁：
         锁标志的状态值为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。
      综上：偏向锁通过对比Mark Word解决加锁问题，避免CAS操作。轻量级锁是通过CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将
      除了拥有锁的线程以外的线程都堵塞。     
#####线程池
    实例见：com.zhy.enableAsync
#####其他并发工具
    1.信号量Semaphore
      用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。
      应用场景：数据库连接（假如有个需求，要读取几万个文件的数据，因为都是IO密集型任务，可以启动几十个线程并发的完成，读到内存后，还需要存储到数据库
      中，而数据库的连接数只有10个，这时必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这时可以用Semaphore来做流控，
      参考代码：com.zhy.enableAsync.ConcurrencyTools.java）
    2.同步计数器CountDownLatch:允许一个或多个线程等待其他线程完成操作。
      应用场景：解析一个Excel里多个sheet的数据时，可以考虑多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完成之后，程序需要提示解析完
      成。
      实现方式：1.join   2.CountDownLatch
      join用于让其他线程等待join线程执行结束。其实现原理是不停检查join线程是否存活，如果join线程存活则让当前线程永远wait，其代码为wait(0);表示永远
      等待下去。直到join线程中止后，线程的this.notifyAll()会被调用，调用notifyAll是在JVM中实现的，所以JDK里看不到。
      参考代码：同上
    3.同步屏障CyclicBarrier
      可循环使用的屏障。让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会打开，所有被屏障拦截的线程才会继续运行。
      CyclicBarrier默认的构造方法是CyclicBarrier(int parties);其参数表示屏障拦截的线程的数量，每个线程调用await()方法告诉CyclicBarrier已经到达
      了屏障，然后当前线程被阻塞。
      代码同上。
    4.CyclicBarrier和CountDownLatch区别
        1.CountDownLatch的计数器只能使用一次，而CycliBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景，如计算发生
        错误，可以重置计数器，并让线程重新执行一次。
        2.CyclicBarrier是先阻塞线程，后让线程开始执行。CountDownLatch是让每个线程执行完成后进行阻塞，直到最后一个线程完成。
#####@Test和main上运行的多线程
    Java分为两种线程：用户线程和守护线程
    守护线程是指程序在运行时，后台提供一种通用服务的线程，比如垃圾回收线程就是一个守护者，并且这种线程不属于程序中不可或缺的部分。因此当所有的非守护
    线程结束时，程序就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。
    守护线程和用户线程没有本质的区别，唯一的不同之处在于虚拟机的离开，如果用户线程已经全部退出运行了，只剩下守护线程，虚拟机就退出了。因为没有了被守
    护者，守护线程就没有工作可做，也就没有继续运行程序的必要了。
    问题：在junit中进行多线程测试时，输出结果与预期结果不一致
    现象：使用@Test测试多线程，发现多线程还未执行完进程就结束了。
    原因：主线程停止后，JUnitStarter.class中main方法会调用System.exit退出虚拟机，如果子线程耗时较长，导致子线程没执行完就销毁了。实例one4方法运行
    在主线程中，外层函数执行完one4等操作后执行System.exit()来退出虚拟机，这时多线程还没执行完，就销毁了。
        而使用main方法，启动完多线程后，主线程结束，但是只有还有普通线程（非守护线程），虚拟机就不会主动退出。